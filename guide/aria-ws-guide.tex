\documentclass[12pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage[romanian]{babel}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{mytitlepage}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[framed,numbered,autolinebreaks,useliterate]{mcode}

\title{Modele Markov Ascunse}
\titlesndline{De la Teorie la Aplicații}
\titledoc{Ghid pentru partea practică}
\author{Alexandru Sorici, Tudor Berariu}
\institute{Asociația Română pentru Inteligență Artificială}
\collaborator{Laboratorul AI-MAS}
\logosrc{graphics/aria-logo-small-white.png}

%% Numele algoritmului
\floatname{algorithm}{Algoritmul}


%% one line comment unnumbered
\newcounter{ALC@tempcntr}% Temporary counter for storage
\newcommand{\LCOMMENT}[1]{%
    \setcounter{ALC@tempcntr}{\arabic{ALC@rem}}% Store old counter
    \setcounter{ALC@rem}{1}% To avoid printing line number
    \item \{#1\}% Display comment + does not increment list item counter
    \setcounter{ALC@rem}{\arabic{ALC@tempcntr}}% Restore old counter
}%


\begin{document}

\mytitlepage
\tableofcontents
\clearpage
\section{Mediul de lucru}
\label{sec:framework}

\subsection{Inițializarea mediului de lucru}
\label{sec:init}

\begin{enumerate}
\item Deschideți \texttt{Matlab} / \texttt{Octave}
\item Schimbați directorul de lucru cu \texttt{aria-hmm}:\\
  \mcode{cd("[.../]aria-hmm")}
\item Adăugați toate subdirectoarele în path:\\
  \mcode{addpath(genpath('.'))}
\end{enumerate}

\subsection{Fișierele \texttt{.stub}}
\label{sec:stubs}

\begin{itemize}
\item le veți folosi ca schelet de cod pentru sesiunile de implementare
\item au secțiuni delimitate de \texttt{<label>-start} și \texttt{<label>-end}
  între care veți adăuga liniile de cod
\item înlăturați sufixul \texttt{.stub} când rezolvați task-urile.
\end{itemize}
\lstinputlisting{m-files/forward-backward.m}

\subsection{Testerul}
\label{sec:tester}

\begin{itemize}
\item Testerul se rulează folosind comanda \mcode{hmm_test}.
  \lstinputlisting{m-files/output.m}
\item Cu \mcode{list} afișați toate testele disponibile.
\item Pentru un anumit task numele testului coincide cu eticheta care delimitează secțiunea de completat.
\end{itemize}

\section{Notații și Denumirile Variabilelor}
\label{sec:notations}

\subsection{Notații folosite în slide-uri și pseudocod}
\label{sec:notation}

\subsubsection{Notații generale}
\label{sec:general}

\begin{description}
\item[$N$] - numărul de stări ascunse
\item[$S$] - mulțimea stărilor ascunse
  \begin{itemize}
  \item $S=\lbrace s_1, s_2, \ldots\ s_N \rbrace$
  \end{itemize}

\item[$A$] - matricea distribuțiilor de probabilitate ale tranzițiilor
  între stări
  \begin{itemize}
  \item $A=\lbrace a_{i,j} \rbrace, \quad 1 \le i \le N, 1 \le j \le
    N$
  \item $a_{i,j} = P(q_{t+1}=s_j \vert q_{t}=s_i)$
  \item fiecare linie este o distribuție de probabilitate:\\
    $\displaystyle\sum_{j=1}^{N}a_{i,j} = 1,\quad 1 \le i \le N$
  \end{itemize}
\item[$\mathbf{\Pi}$] - distribuția stării inițiale
  \begin{itemize}
  \item $\mathbf{\Pi} = \lbrace \pi_i \rbrace,\quad 1 \le i \le N$
  \item $\pi_i = P(q_1 = s_i)$
  \item $\displaystyle\sum_{i=1}^{N}\pi_i = 1$
  \end{itemize}
\item[$M$] - numărul de valori observabile distincte (pentru cazul
  discret)
\item[$V$] - mulțimea valorilor observabile
\item[$B$] - matricea distribuțiilor de probabilitate ale valorilor
  observabile
  \begin{itemize}
  \item $B=\lbrace b_{j,k} \rbrace, \quad 1 \le j \le N, 1 \le k \le
    M$
  \item $\displaystyle\sum_{k=1}^{M}b_{j,k} = 1,\quad 1 \le j \le N$
  \end{itemize}
\item[$\mathbf{\lambda}$] - parametrii Modelului Markov Ascuns
  \begin{itemize}
  \item $\mathbf{\lambda} = (A, B, \Pi)$
  \end{itemize}
\item[$Q$] - o secvență de stări
\item[$O$] - o secvență de observații
\item[$T$] - lungimea unei secvențe de stări / valori observate
\end{description}

\subsubsection{Algoritmul Forward-Backward}
\label{sec:fb-not}

\begin{description}
\item[$\alpha$] - variabilele $\alpha$ (înainte)
  \begin{itemize}
  \item $\alpha_{t,i}=P(o_1,o_2,\ldots,o_t, q_t = s_i \vert \lambda), \quad  \scriptstyle{1 \le t \le T, 1 \le i \le N}$
  \item $P(O \vert \lambda) = \displaystyle\sum_{i=1}^{N}\alpha_{T,i}$
  \item Calcul:
    \begin{description}
    \item[$\mathbf{t=1}$:] $\alpha_{1,i}=\pi_ib_i(o_1), \quad \scriptstyle{1 \le i \le N}$
    \item[$\mathbf{t>1}$:] $\alpha_{t+1,j}=\Big[
        \displaystyle\sum_{i=1}^{N}\alpha_{t,j}a_{i,j}\Big]
        b_{j}(o_{t+1}), \quad \substack{1 \le t \le T-1\\1\le j \le N}$ 
    \end{description}
  \end{itemize}
\item[$\beta$] - variabilele $\beta$ (înapoi)
  \begin{itemize}
  \item $\beta_{t,i}=P(o_{t+1} o_{t+2} \cdots o_{T} \vert q_t = s_i,
      \lambda)$
    \item $P(O \vert \lambda) = \displaystyle\sum_{i=1}^{N}\beta_{1,i}$
    \item Calcul:
      \begin{description}
      \item[$\mathbf{t=T}$:] $\beta_{T,i}=1,\scriptstyle{\quad 1 \le i \le N}$
      \item[$\mathbf{t<T}$] $\beta_{t,i}=\displaystyle\sum_{j=1}^{N}a_{i,j}b_j(o_{t+1})\beta_{t+1,j},
    \quad \scriptstyle{t = T-1, T-2, \ldots , 1, 1 \le i \le N}$
      \end{description}
  \end{itemize}
\item[$\hat{\alpha}$] - variabilele $\alpha$ scalate
\item[$\hat{\beta}$] - variabilele $\beta$ scalate
\item[$c_t$] - coeficientul de scalare pentru momentul de timp $t$
  \begin{itemize}
  \item Notație: $C_t = c_1 \cdot c_2 \cdot \ldots \cdot c_t$
  \item $\hat{\alpha}_{t,i} = C_t\alpha_{t,i}$
  \end{itemize}
\end{description}  


\subsubsection{Algoritmul Viterbi}
\label{sec:viterbi}

\begin{description}
\item[$\delta$] - variabilele $\delta$
  \begin{itemize}
  \item $\delta_{t,i}$ - cea mai mare probabilitate a unei secvențe de
    stări de lungime $t$ care ajunge în $s_i$ și explică primele $t$
    valori observate
  \item
    $\delta_{t,i}=\underset{q_1,\ldots,q_{t-1}}{\operatorname{max}}
    P([q_1 q_2 \ldots q_{t-1} s_i], [o_1, o_2, \ldots o_t] \vert
    \lambda)$
  \item Calcul:
    \begin{description}
    \item[$\mathbf{t=1}$:] $\delta_{1,i} = \pi_{i}b_i(o_1),
      \scriptstyle{\quad 1 \le i \le N}$
    \item[$\mathbf{t>1}$:] $\delta_{t,j} = [\underset{i
      }{\operatorname{max}}\; \delta_{t-1,i} \cdot a_{i,j}] \cdot
      b_{j}(o_{t}) \quad \scriptstyle{2 \le t \le T, 1 \le j \le N}$
    \end{description}
  \end{itemize}
\item[$\psi$] - variabilele $\psi$
  \begin{itemize}
  \item $\psi_{t,i}$ - starea de la $t-1$ care a dus la valoarea
    maximă $\delta_{t-1,i}\cdot a_{i,j}$
  \item Calcul:
    \begin{description}
    \item[$\mathbf{t=1}$:] $\psi_{1,i} = 0, \quad\scriptstyle{1 \le i
        \le N}$
    \item[$\mathbf{t>1}$:] $\psi_{t,i} =
      \underset{i}{\operatorname{argmax}}\; \delta_{t-1,i}\cdot
      a_{i,j} \quad \scriptstyle{2 \le t \le T, 1 \le j \le N}$
    \end{description}
  \end{itemize}
\item[$\phi$] - variabilele $\phi$ ($\delta$ logaritmate)
  \begin{itemize}
  \item $\phi_{t,i}=\underset{q_1,\ldots,q_{t-1}}{\operatorname{max}}
    \log(P(q_1,\ldots,q_{t-1},q_t=s_i,o_1,\ldots,o_t\vert
    \lambda))=\log(\delta_{t,i})$
  \item Calcul:
    \begin{description}
    \item[$t=1$:] $\phi_{1,i} = \log(\pi_{i}) + \log(b_i(o_1)),
      \quad\scriptstyle{1 \le i \le N}$
    \item[$t>1$:] $\phi_{t,j} = [\underset{i}{\operatorname{max}}\; \phi_{t-1,i} +
        log(a_{i,j})] + \log(b_{j}(o_{t}))
        \quad \scriptstyle{2 \le t \le T, 1 \le j \le N}$
    \end{description}
  \end{itemize}
\end{description}

\subsubsection{Algoritmul Baum-Welch}
\label{sec:baum-welch-not}

\begin{description}
\item[$\xi$] - variabilele $\xi$
  \begin{itemize}
  \item $\xi_{t,i,j} = \xi_t(i,j) = P(q_t=s_i,q_{t+1}=s_j \vert O,
    \lambda)$
  \item $\xi_{t,i,j} = \frac{\alpha_{t,i}\cdot a_{i,j} \cdot b_j(o_{t+1}) \cdot
		        \beta_{t+1,j}}{
		        \displaystyle\sum_{k=1}^{N}\displaystyle\sum_{l=1}^{N}
		        \alpha_{t,k}\cdot a_{k,l} \cdot b_l(o_{t+1}) \cdot
		        \beta_{t+1,l}}$
  \end{itemize}
\item[$\gamma$] - variabilele $\gamma$
  \begin{itemize}
  \item $\gamma_{t,i} = \gamma_t(i) = P(q_t = s_i \vert O, \lambda)$
  \item $\gamma_t(i) = \displaystyle\sum_{j=1}^{N}\xi_t(i,j)$
  \end{itemize}
\end{description}

\subsection{Variabile în fișierele \texttt{.m}}
\label{sec:m-variables}

\begin{itemize}
\item General:
  \begin{itemize}
  \item \mcode{N} - scalar
  \item \mcode{M} - scalar
  \item \mcode{T} - scalar
  \item \mcode{A} - matrice de dimensiune $N \times N$
  \item \mcode{B} - matrice de dimensiune $N \times M$
  \item \mcode{Pi} - matrice de dimensiune $1 \times N$
  \item \mcode{O} - matrice de dimensiune $1 \times T$
  \end{itemize}
\item Forward-Backward:
  \begin{itemize}
  \item \mcode{Alpha} - matrice de dimensiune $T \times N$
    \begin{itemize}
    \item va reprezenta, de fapt, variabilele $\hat{\alpha}$
    \end{itemize}
  \item \mcode{Beta} - matrice de dimensiune $T \times N$
    \begin{itemize}
    \item va reprezenta, de fapt, variabilele $\hat{\beta}$
    \end{itemize}
  \item \mcode{Scale} - matrice de dimesniune $1 \times T$
    \begin{itemize}
    \item va reprezenta coeficienții de scalare $c_i$
    \end{itemize}
  \item \mcode{logP} - scalar
  \end{itemize}
\item Viterbi:
  \begin{itemize}
  \item \mcode{Phi} - matrice de dimensiune $T \times N$
  \item \mcode{Psi} - matrice de dimensiune $T \times N$
  \item \mcode{Q} - matrice de dimensiune $1 \times T$
  \end{itemize}
\item Baum-Welch (avem mai multe observații)
  \begin{itemize}
  \item \mcode{L} - scalar, numărul de observații
  \item \mcode{TMax} - scalar, lungimea maximă a observațiilor
  \item \mcode{T} - matrice de dimensiune $1 \times L$, lungimea
    observației $l$
  \item \mcode{Alpha} - matrice de dimensiune $L \times TMax \times N$
  \item \mcode{Beta} - matrice de dimensiune $L \times TMax \times N$
  \item \mcode{logP} - matrice de dimensiune $1 \times L$
  \end{itemize}
\end{itemize}


\section{Task-uri de implementare}
\label{sec:tasks}

\subsection{Algoritmul Forward-Backward}
\label{sec:fb}

\subsubsection{Descriere}
\label{sec:descr-fb}

Primul task de programare constă în calcularea valorilor matricelor
\mcode{Alpha}, \mcode{Beta} și a valorii \mcode{logP}, date fiind o
secvență de observații \mcode{O} și parametrii modelului: matricele
\mcode{A}, \mcode{B} și \mcode{Pi}.

Scheletul de cod de la care veți pleca se află în fișierul\\
\texttt{hmm/forward\_backward\_disc.m.stub}. Eliminați sufixul
\texttt{.stub} și salvați în fișierul
\texttt{hmm/forward\_backward\_disc.m}.

Funcția pe care o veți completa este \mcode{forward_backward_disc}:

\lstinputlisting[firstline=1,
lastline=1]{../src/final/hmm/forward_backward_disc.m.stub}

Pentru rezolvare veți completa trei secțiuni.
 Pentru calculul
valorilor matricei \mcode{Alpha} veți completa în zona delimitată de
etichetele \mcode{alpha_disc}.
\lstinputlisting[firstline=42,
lastline=46]{../src/final/hmm/forward_backward_disc.m.stub}
 Pentru calculul
valorilor matricei \mcode{Beta} veți completa în zona delimitată de
etichetele \mcode{beta_disc}.
\lstinputlisting[firstline=48,
lastline=52]{../src/final/hmm/forward_backward_disc.m.stub}
 Pentru calculul
valorii \mcode{logP} veți completa în zona delimitată de
etichetele \mcode{prob_disc}.
\lstinputlisting[firstline=54,
lastline=58]{../src/final/hmm/forward_backward_disc.m.stub}


\subsubsection{Teste automate}
\label{sec:tester-fb}

Pentru a testa codul folosiți comanda:
\begin{itemize}
\item \mcode{hmm_test("alpha_disc");} pentru testarea valorilor
  matricelor \mcode{Alpha} și \mcode{Scale}
\item \mcode{hmm_test("beta_disc");} pentru testarea valorilor
  matricei \mcode{Beta}
\item \mcode{hmm_test("prob_disc");} pentru testarea valorilor
  matricei \mcode{logP}
\end{itemize}
Indicați apoi numele fișierului (sau tastați simplu ENTER dacă ați
folosit numele sugerat).

\subsubsection{Pseudocod}
\label{sec:pseudocod-fb}

\begin{algorithm}[H]
  \caption{Calculul variabilelor $\alpha$}
  \label{alg1:alpha}
  \algsetup{indent=3em}
  \begin{algorithmic}[1]
    \FOR{$i=1$ to $N$} \STATE $\ddot{\alpha}_{1,i} \leftarrow
    \pi_i \cdot b_i(o_1)$
    \ENDFOR
    \STATE $c_1 \leftarrow (\displaystyle\sum_{i=1}^{N}
    \ddot{\alpha}_{1,i})^{-1}$ \FOR{$i=1$ to $N$} \STATE
    $\hat{\alpha}_{1,i} \leftarrow c_1 \cdot \ddot{\alpha}_{1,i}$
    \ENDFOR
    \FOR{$t=1$ to $T-1$} \FOR{$i=1$ to $N$} \STATE
    $\ddot{\alpha}_{t+1,i} \leftarrow \Big[
    \displaystyle\sum_{i=1}^{N}\hat{\alpha}_{t,i}a_{i,j}\Big]
    b_{j}(o_{t+1})$
    \ENDFOR
    \STATE $c_{t+1} \leftarrow (\displaystyle\sum_{i=1}^{N}
    \ddot{\alpha}_{t+1,i})^{-1}$ \FOR{$i=1$ to $N$} \STATE
    $\hat{\alpha}_{t+1,i} \leftarrow c_{t+1} \cdot
    \ddot{\alpha}_{t+1,i}$
    \ENDFOR
    \ENDFOR
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{Calculul $P(O \vert \lambda)$}
  \label{alg2:logP}
  \algsetup{indent=3em}
  \begin{algorithmic}[1]
    \STATE $logP \leftarrow -\displaystyle\sum_{t=1}^{T}c_t$
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{Calculul variabilelor $\beta$}
  \label{alg3:beta}
  \algsetup{indent=3em}
  \begin{algorithmic}[1]
    \FOR{$i=1$ to $N$} \STATE $\hat{\beta}_{T,i} \leftarrow
    c_T$
    \ENDFOR
    \FOR{$t=(T-1)$ to $1$} \FOR{$i=1$ to $N$} \STATE
    $\hat{\beta}_{t,i} \leftarrow \displaystyle\sum_{j=1}^{N}
    a_{i,j} b_{j}(o_{t+1}) \hat{\beta}_{t+1,j} \cdot c_t$
    \ENDFOR
    \ENDFOR
  \end{algorithmic}
\end{algorithm}


\subsection{Algoritmul Viterbi}
\label{sec:viterbi}

\subsubsection{Descriere}
\label{sec:desc-viterbi}

A doua sarcină de programare vă cere să implementați algoritmul
Viterbi, mai precis să calculați valorile $\phi$ și $\psi$ și cea mai
bună secvență $Q$.

Calculați valorile matricelor \mcode{Phi} și \mcode{Psi} pentru
$t>1$. Completați cu instrucțiunile necesare în secțiunea delimitată
de \mcode{phi_psi_disc-start} și \mcode{phi_psi_disc-end}
\lstinputlisting[firstline=40,lastline=46]{../src/final/hmm/viterbi_disc.m.stub}

Refaceți cea mai bună cale în vectorul \mcode{Q}. Scrieți codul în
liniile delimitate de \mcode{path-disc-start} și
\mcode{path-disc-end}.

\lstinputlisting[firstline=51,lastline=55]{../src/final/hmm/viterbi_disc.m.stub}


\subsubsection{Testare}
\label{sec:test-viterbi}

Pentru a vă testa codul scris folosiți comanda:
\begin{itemize}
\item \mcode{hmm_test("phi_psi_disc");} pentru testarea valorilor
  matricelor \mcode{Phi} și \mcode{Psi}
\item \mcode{hmm_test("path_disc");} pentru testarea valorilor
  vectorului \mcode{Q}
\end{itemize}
Indicați apoi numele fișierului (sau tastați simplu ENTER dacă ați
folosit numele sugerat).


\subsubsection{Pseudocod}
\label{sec:pseudocod-viterbi}

\begin{algorithm}[H]
  \caption{Viterbi: Calculul celei mai probabile secvențe $Q_{\text{best}}$}
  \label{alg:viterbi}
  \algsetup{indent=3em}
  \begin{algorithmic}[2]
    \FOR{$i=1$ to $N$}
    \STATE $\phi_{1,i}$ $\leftarrow$ $\log(\pi_{i}) + \log(b_i(o_1))$
    \STATE $\psi_{1,i}$ $\leftarrow$ $0$
    \ENDFOR
    \FOR{$t=2$ to $T$}
    \FOR{$i=1$ to $N$}
    \STATE $\phi_{t,j}$ $\leftarrow$ $[\underset{i}{\operatorname{max}}\; \phi_{t-1,i} +
    log(a_{i,j})] + \log(b_{j}(o_{t}))$
    \STATE $\psi_{t,i}$ $\leftarrow$ $\underset{i}{\operatorname{argmax}}\; \phi_{t-1,i} +
    \log(a_{i,j})$
    \ENDFOR
    \ENDFOR
    \STATE $\log(P(Q_{\text{best}} \vert O, \lambda))$ $\leftarrow$ $\underset{i}{\operatorname{max}}\; \phi_{T,i}$
    \STATE $q_{T_{\text{best}}}$ $\leftarrow$ $\underset{i}{\operatorname{argmax}}\; \phi_{T,i}$
    \FOR{$t=T-1$ to $1$}
    \STATE $q_{t_{\text{best}}}$ $\leftarrow$ $\psi_{t+1}(q_{t+1_{\text{best}}})$
    \ENDFOR
  \end{algorithmic} 
\end{algorithm}
 
  
\subsection{Algoritmul Baum-Welch}
\label{sec:baum-welch}

\subsubsection{Descriere}
\label{sec:desc}

În această parte practică veți implementa o parte a algoritmului
Baum-Welch pentru estimarea parametrilor \mcode{A},\mcode{B} și
\mcode{Pi} pe baza a \mcode{L} observații de lungime maximă
\mcode{Tmax}.

Scheletul de cod de la care veți pleca se află în fișierul\\
\texttt{hmm/baum\_welch\_disc.m.stub}. Eliminați sufixul
\texttt{.stub} și salvați în fișierul
\texttt{hmm/baum\_welch\_disc.m}.

Funcția pe care o veți completa este \mcode{baum_welch_disc}:

\lstinputlisting[firstline=1,
lastline=1]{../src/final/hmm/baum_welch_disc.m.stub}


Pasul \emph{expectation} este \emph{rezolvat} de algoritmul
Forward-Backward.

\lstinputlisting[firstline=76,
lastline=81]{../src/final/hmm/baum_welch_disc.m.stub}


Trebuie să implementați doar reestimarea matricelor \mcode{A} și
\mcode{B} pe baza matricelor \mcode{Alpha}, \mcode{Beta},
\mcode{Scale} și \mcode{logP} și vechilor valori din \mcode{A},
\mcode{B}.

Atenție: matricele \mcode{Alpha} și \mcode{Beta} sunt de dimensiune
\mcode{L}$\times$\mcode{N}$\times$\mcode{N}, matricea \mcode{Scale} are
dimensiunea \mcode{L}$\times$\mcode{N}, iar \mcode{logP} este un vector de
dimensiune $1\times$\mcode{L}.

Scrieți codul în secțiunea următoare:

\lstinputlisting[firstline=96,
lastline=98]{../src/final/hmm/baum_welch_disc.m.stub}

\subsubsection{Testare}
\label{sec:test-bm}

Pentru a testa codul folosiți comanda
\mcode{hmm_test("maximization_disc");}.  Indicați apoi numele
fișierului (sau tastați simplu ENTER dacă ați folosit numele sugerat).

\subsubsection{Pseudocod}
\label{sec:pseudo}

\begin{algorithm}[H]
  \caption{Baum-Welch}
  \label{alg-baum-welch-1}
  \algsetup{indent=2.25em}
  \begin{algorithmic}[1]
    \STATE intrări: $O \leftarrow$ secvența de observații, $\epsilon
    \leftarrow$ prag de convergență
    
    \STATE \LCOMMENT{\emph{Initializare}} \STATE init. uniformă $\Pi$
    ($\Pi_i = 1/N, 1 \le i \le N$) \STATE init. aleatoare $a_{i,j}$,
    a. î. $\sum_{j=1}^{N}a_{i,j} = 1,\quad 1 \le j \le N$ \STATE
    init. uniformă $b_{j,k}$ ($b_{j,k} = 1/M,\quad 1 \le j \le N, 1
    \le k \le M$) \STATE $oldP$ $\leftarrow$ 0 \STATE
    \LCOMMENT{\emph{E STEP - în afara buclei}} \FOR{$l=1$ to $L$}
    \STATE $[logP_l, \hat{\alpha}_l, \hat{\beta}_l, Scale_l] =
    forward\_backward(O_l, \Pi, A, B)$
    \ENDFOR
    \STATE $logP$ $\leftarrow$ $\displaystyle\sum_{l=1}^{L}logP(l)$
    \vspace*{0.5em} \WHILE{{$\vert logP - oldP \vert < \epsilon$}}
    \STATE $oldP$ $\leftarrow$ $logP$ \STATE \LCOMMENT{M STEP -
      recalculeaza $\Pi$, $A$ și $B$} \STATE $\Pi =
    update\_pi\_procedure(\hat{\alpha}, \hat{\beta}, Scale)$ \STATE $A
    = update\_A\_procedure(O, \hat{\alpha}, \hat{\beta}, Scale)$
    \STATE $B = update\_B\_procedure(O, \hat{\alpha}, \hat{\beta},
    Scale)$
    
    \STATE \LCOMMENT{\emph{E STEP - calculeaza variantele scalate
        pentru $\alpha$ și $\beta$ și probabilitatea curentă (log
        likelihood - $log(P(O \vert \bar{\lambda}))$) a secvenței
        observate}} \FOR{$l=1$ to $L$} \STATE $[logP_l,
    \hat{\alpha}_l, \hat{\beta}_l, Scale_l] = forward\_backward(O_l,
    \Pi, A, B)$
    \ENDFOR
    \STATE $logP$ $\leftarrow$ $\displaystyle\sum_{l=1}^{L}logP(l)$
    
    \ENDWHILE
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{Baum-Welch}
  \label{alg-baum-welch-2}
  \algsetup{indent=3em}
  \begin{algorithmic}[1]
    \STATE \emph{Function update\_pi\_procedure}($\hat{\alpha}$,
    $\hat{\beta}$, $Scale$) \FOR{$i=1$ to $N$} \STATE $\Pi_i =
    \frac{\displaystyle\sum_{l=1}^{L}\hat{\alpha}_{l,1,i} \cdot
      \hat{\beta}_{l,1}(i) / Scale_1}
    {\displaystyle\sum_{l=1}^{L}\sum_{j=1}^{N}{\hat{\alpha}_{l,1}(j)
        \cdot \hat{\beta}_{l,1}(j) / Scale_1}}$
    \ENDFOR
    \RETURN $\Pi$ \STATE \emph{EndFunction}
  \end{algorithmic}

  \begin{algorithmic}[1]
    \vspace*{0.5em} \STATE \emph{Function update\_A\_procedure}($O$,
    $\hat{\alpha}$, $\hat{\beta}$, $Scale$) \FOR{$i=1$ to $N$}
    \FOR{$j=1$ to $N$} \STATE $a_{i,j} =
    \frac{\displaystyle\sum_{l=1}^{L}\sum_{t=1}^{T_l-1}{
        \hat{\alpha}_{l,t,i}\cdot a_{ij} \cdot b_{l,j}(o_{l,t+1}) \cdot
        \hat{\beta}_{l,t+1,j}}}
    {\displaystyle\sum_{l=1}^{L}\sum_{t=1}^{T_l-1}\sum_{j=1}^{N}{\hat{\alpha}_{l,t,i}\cdot
        a_{i,j} \cdot b_{l,j}(o_{l,t+1}) \cdot \hat{\beta}_{l,t+1,j}}}$
    \ENDFOR
    \ENDFOR
    \RETURN $a$ \STATE \emph{EndFunction}
  \end{algorithmic}

  \begin{algorithmic}[1]
    \vspace*{0.5em} \STATE \emph{Function update\_B\_procedure}($O$, $\hat{\alpha}$,
    $\hat{\beta}$, $Scale$) \FOR{$j=1$ to $N$} \FOR{$k=1$ to $M$}
    \STATE $b_{j,k} =
    \frac{\displaystyle\sum_{l=1}^{L}\sum_{t=1,O(t)=v_k}^{T(l)}
      {\hat{\alpha}_{l,t,j} \cdot \hat{\beta}_{l,t,j} / Scale_{l,t}}}
    {\displaystyle\sum_{l=1}^{L}\sum_{t=1}^{T(l)}
      {\hat{\alpha}_{l,t,j} \cdot \hat{\beta}_{l,t,j} / Scale_{l,t}}}$
    \ENDFOR
    \ENDFOR
    \RETURN $b$ \STATE \emph{EndFunction}
  \end{algorithmic}
\end{algorithm}

\subsection{Precalcularea Matricei B în cazul multidimensional}
\label{sec:b-matrix-precom}


\subsubsection{Descriere}

todo tudor

\subsubsection{Testare automată}

Pentru a testa codul folosiți comanda
\mcode{hmm_test("precomp_b_disc");}.  Indicați apoi numele
fișierului (sau tastați simplu ENTER dacă ați folosit numele sugerat).

\subsubsection{Pseudocod}

\begin{algorithm}[H]
  \caption{Precalcularea matricei B în cazul multidimensional}
  \label{alg:alexinmultestematrici}
  \algsetup{indent=3em}
  \begin{algorithmic}[2]
    \FOR{$l=1$ to $L$}
    \FOR{$t=1$ to $T(l)$}
    \FOR{$i=1$ to $N$}
    \STATE $Bprod(l,i,t)$ $\leftarrow$ $\displaystyle\prod_{r=1}^{R}B(i,O(l,r,t),r)$
    \ENDFOR
    \ENDFOR
    \ENDFOR
  \end{algorithmic} 
\end{algorithm}


\subsection{Recunoașterea Simbolurilor}
\label{sec:symbol-recognition}


\subsubsection{Descriere}


\subsubsection{Testare automată}
\label{sec:testare-ultima}

Pentru a testa codul folosiți comanda \mcode{hmm_test("symbolrec");}.
Indicați apoi numele fișierului (sau tastați simplu ENTER dacă ați
folosit numele sugerat).


\section{Soluții}
\label{sec:solutions}

\subsection{Algoritmul Forward-Backward}
\label{sec:fb-sol}

\lstinputlisting[firstline=42,
lastline=76]{../src/final/hmm/forward_backward_disc.m.solution}

\subsection{Algoritmul Viterbi}
\label{sec:viterbi-sol}

\lstinputlisting[firstline=40,
lastline=60]{../src/final/hmm/viterbi_disc.m.solution}

\subsection{Algoritmul Baum-Welch}
\label{sec:baum-welch-sol}

Din testele de performanță făcute, s-a dovedit mai eficient să fie
aduse matricele \mcode{O}, \mcode{A}, \mcode{B}, \mcode{Alpha} și
\mcode{Beta} în 4 dimensiuni (prin copiere cu operația \mcode{repmat}
și interschimbare a dimensiunilor cu operațiile \mcode{permute} și
\mcode{shiftdim}) pentru a fi înmulțite apoi element cu element.

\lstinputlisting[firstline=96,
lastline=137]{../src/final/hmm/baum_welch_disc.m.solution}

\subsection{Recunoașterea Simbolurilor}
\label{sec:symbol-recognition-sol}


\subsubsection{Precalcularea matricei $B$}
\label{sec:precomp-b-sol}

\lstinputlisting[firstline=96,
lastline=109]{../src/final/hmm/baum_welch_multi_disc.m.solution}

\subsubsection{Clasificarea (recunoașterea) unui simbol}
\label{sec:classify-sol}

\lstinputlisting[firstline=70,
lastline=109]{../src/final/symbolapp/testing/symbol_recognize.m.solution}


\end{document}
